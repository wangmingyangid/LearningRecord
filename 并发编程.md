**极客时间并发编程学习**

## 01 |可见性、原子性和有序性问题：并发编程Bug的源头

###问题1：缓存导致的可见性

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为**可见性**。

多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，**当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存**。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。

<img src="D:\E\学习记录\java并发编程图示\多核CPU的缓存与内存关系图.png" style="zoom:50%;" />

### 问题2：线程切换带来的原子性问题

**我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性**。

CPU 能保证的原子操作是 **CPU 指令级别的，而不是高级语言的操作符**，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。

任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。

* 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；
* 指令 2：之后，在寄存器中执行 +1 操作；
* 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

操作系统做任务切换，**可以发生在任何一条 CPU 指令执行完**，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。

<img src="D:\E\学习记录\java并发编程图示\非原子操作的执行路径示意图.png" style="zoom:50%;" />

###问题3：编译优化带来的有序性问题

**有序性** 指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。**不过有时候编译器及解释器的优化可能导致意想不到的 Bug** 。

在 Java 领域一个经典的案例就是利用双重检查创建单例对象

~~~java
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}
~~~

假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。

这看上去一切都很完美，无懈可击，**但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上**，我们以为的 new 操作应该是：

1. 分配一块内存 M；
2. 在内存 M 上初始化 Singleton 对象；
3. 然后 M 的地址赋值给 instance 变量。

但是实际上优化后的执行路径却是这样的：

1. 分配一块内存 M；
2. 将 M 的地址赋值给 instance 变量；
3. 最后在内存 M 上初始化 Singleton 对象。

优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量**就可能触发空指针异常**。

<img src="D:\E\学习记录\java并发编程图示\双重检查创建单例的异常执行路径.png" style="zoom:50%;" />



##02 | Java内存模型：看Java如何解决可见性和有序性问题

### 2.1 什么是 java 内存模型

Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，**Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法** 。具体来说，**这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则** 。

###2.2 volitile关键字

volatile 关键字并不是 Java 语言的特产，古老的 C 语言里也有，**它最原始的意义就是禁用 CPU 缓存 **。

例如，我们声明一个 volatile 变量 volatile int x = 0，它表达的是：**告诉编译器，对这个变量的读写，不能使用 CPU 缓存，必须从内存中读取或者写入**。

### 2.3 Happens-Before 规则

含义：前面一个操作的结果对后续操作是可见的

#### 2.3.1 程序的顺序性规则

**这条规则是指在一个线程中** ，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。这还是比较容易理解的，按照程序的顺序，第 5行代码 “x = 42;” Happens-Before 于第 6行代码 “v = true;”，这就是规则 1 的内容，也比较符合单线程里面的思维：**程序前面对某个变量的修改一定是对后续操作可见的** 。

~~~java
class VolatileExample {
  int x = 0;
  volatile boolean v = false;
  public void writer() {
    x = 42;
    v = true;
  }
  public void reader() {
    if (v == true) {
      // 这里x会是多少呢？
    }
  }
}
~~~

#### 2.3.2 volatile 变量规则

这条规则是指对一个 volatile 变量的**写操作**， Happens-Before 于后续对这个 volatile 变量的**读操作**。

#### 2.3.3 传递性

这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。

<img src="D:\E\学习记录\java并发编程图示\代码中的传递性规则.png" style="zoom:50%;" />

从图中，我们可以看到：

1. “x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；
2. 写变量“v=true” Happens-Before 读变量 “v=true”，这是规则 2 的内容 。

根据这个传递性规则，我们得到结果：“x=42” Happens-Before **读变量 **“v=true”

如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的。也就是说，线程 B 能看到 “x == 42”

#### 2.3.4 管程中锁的规则

这条规则是指对一个锁的**解锁**  Happens-Before 于后续对这个锁的**加锁** 。

**管程** 是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。

管程中的锁在 Java 里是**隐式实现** 的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。

~~~java
synchronized (this) { //此处自动加锁
  // x是共享变量,初始值=10
  if (this.x < 12) {
    this.x = 12; 
  }  
} //此处自动解锁
~~~

所以结合规则 4——管程中锁的规则，可以这样理解：假设 x 的初始值是 10，线程 A 执行完代码块后 x 的值会变成 12（执行完自动释放锁），线程 B 进入代码块时，能够看到线程 A 对 x 的写操作，也就是线程 B 能够看到 x==12。

#### 2.3.5 线程 start() 规则

这条是关于线程启动的。如果线程 A 调用线程 B 的 start() 方法（即在**线程 A 中启动线程 B**），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。

~~~java
Thread B = new Thread(()->{
  // 主线程调用B.start()之前
  // 所有对共享变量的修改，此处皆可见
  // 此例中，var==77
});
// 此处对共享变量var修改
var = 77;
// 主线程启动子线程
B.start();
~~~

#### 2.3.6 线程 join() 规则

这条是关于线程等待的。如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。

~~~java
Thread B = new Thread(()->{
  // 此处对共享变量var修改
  var = 66;
});
// 例如此处对共享变量修改，
// 则这个修改结果对线程B可见
// 主线程启动子线程
B.start();
B.join()
// 子线程所有对共享变量的修改
// 在主线程调用B.join()之后皆可见
// 此例中，var==66
~~~

### 2.4 final关键字

final 修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。

在 1.5 以后 Java 内存模型对 final 类型变量的重排进行了约束。现在只要我们提供正确构造函数没有“逸出”，就不会出问题了。

~~~txt
The values for an object's final fields are set in its constructor. Assuming the object is constructed "correctly", once an object is constructed, the values assigned to the final fields in the constructor will be visible to all other threads without synchronization. In addition, the visible values for any other object or array referenced by those final fields will be at least as up-to-date as the final fields.
What does it mean for an object to be properly constructed? It simply means that no reference to the object being constructed is allowed to "escape" during construction.
~~~

“逸出”有点抽象，我们还是举个例子吧，在下面例子中，在构造函数里面将 this 赋值给了全局变量 global.obj，这就是“逸出”，线程通过 global.obj 读取 x 是有可能读到 0 的。因此我们一定要避免“逸出”。

~~~java
final int x;
// 错误的构造函数
public FinalFieldExample() { 
  x = 3;
  y = 4;
  // 此处就是讲this逸出，
  global.obj = this;
}
~~~

##03 | 互斥锁（上）：解决原子性问题

一个或者多个操作在 CPU 执行的过程中不被中断的特性，称为“原子性”

### 3.1如何解决原子性问题

原子性问题的源头是线程切换，如果能够禁用线程切换那不就能解决原子性的问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以**禁止 CPU 发生中断**就能够禁止线程切换。

在早期单核 CPU 时代，这个方案的确是可行的，而且也有很多应用案例，但是并不适合多核场景。

**这里我们以 32 位 CPU 上执行 long 型变量的写操作为例来说明这个问题**，long 型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低 32 位，如下图所示）。

<img src="D:\E\学习记录\java并发编程图示\原子性问题举例.png" style="zoom:50%;" />

在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1 上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位的话，那就有可能出现我们开头提及的诡异 Bug 了。

**“同一时刻只有一个线程执行”**这个条件非常重要，我们称之为互斥。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。

### 3.2 锁模型

<img src="D:\E\学习记录\java并发编程图示\锁模型.png" style="zoom:50%;" />

首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源 R；其次，我们要保护资源 R 就得为它创建一把锁 LR；最后，针对这把锁 LR，我们还需在进出临界区时添上加锁操作和解锁操作。另外，**在锁 LR 和受保护资源之间，特地用了一条线做了关联，这个关联关系非常重要**。

### 3.3 Java 语言提供的锁技术：synchronized

锁是一种通用的技术方案，Java 语言提供的 synchronized 关键字，就是锁的一种实现。synchronized 关键字可以用来修饰方法，也可以用来修饰代码块，它的使用示例基本上都是下面这个样子：

~~~java
class X {
  // 修饰非静态方法
  synchronized void foo() {
    // 临界区
  }
  // 修饰静态方法
  synchronized static void bar() {
    // 临界区
  }
  // 修饰代码块
  Object obj = new Object()；
  void baz() {
    synchronized(obj) {
      // 临界区
    }
  }
}  
~~~

说明：

1. Java 编译器会在 synchronized 修饰的方法或代码块前后**自动加上加锁 lock() 和解锁 unlock()** ，这样做的好处就是加锁 lock() 和解锁 unlock() 一定是成对出现的

2.  Java 的一条隐式规则（锁对象）：

   当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就是 Class X；当修饰非静态方法的时候，锁定的是当前实例对象 this。

### 3.4 举例

~~~java
class SafeCalc {
  long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}
~~~

上面的代码转换为我们提到的锁模型，就是下面图示这个样子。get() 方法和 addOne() 方法都需要访问 value 这个受保护的资源，这个资源用 this 这把锁来保护。线程要进入临界区 get() 和 addOne()，必须先获得 this 这把锁，这样 get() 和 addOne() 也是互斥的。

<img src="D:\E\学习记录\java并发编程图示\保护临界区示意图1.png" style="zoom:50%;" />

### 3.5 锁和受保护资源的关系

受保护资源和锁之间的关联关系非常重要，他们的关系是怎样的呢？一个合理的关系是：**受保护资源和锁之间的关联关系是 N:1 的关系。** 

现实世界里，我们可以用多把锁来保护同一个资源，但在并发领域是不行的，并发领域的锁和现实世界的锁不是完全匹配的。不过倒是可以用同一把锁来保护多个资源，这个对应到现实世界就是我们所谓的“包场”了。

~~~java
class SafeCalc {
  static long value = 0L;
  synchronized long get() {
    return value;
  }
  synchronized static void addOne() {
    value += 1;
  }
}
~~~

仔细观察，就会发现改动后的代码是**用两个锁保护一个资源**。这个受保护的资源就是静态变量 value，两个锁分别是 this 和 SafeCalc.class。我们可以用下面这幅图来形象描述这个关系。**由于临界区 get() 和 addOne() 是用两个锁保护的，因此这两个临界区没有互斥关系，临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题了。**

<img src="D:\E\学习记录\java并发编程图示\两把锁保护同一个资源.png" style="zoom:50%;" />

